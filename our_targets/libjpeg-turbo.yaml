"functions":
- "name": tj3Decompress16
  "params":
  - "name": handle
    "type": void
  - "name": jpegBuf
    "type": unsigned char
  - "name": jpegSize
    "type": unsigned long
  - "name": dstBuf
    "type": unsigned char
  - "name": pitch
    "type": int
  - "name": pixelFormat
    "type": int
  - "name": handle
    "type": void
  - "name": jpegBuf
    "type": unsigned char
  - "name": jpegSize
    "type": unsigned long
  - "name": dstBuf
    "type": short
  - "name": pitch
    "type": int
  - "name": pixelFormat
    "type": int
  - "name": handle
    "type": void
  - "name": jpegBuf
    "type": unsigned char
  - "name": jpegSize
    "type": unsigned long
  - "name": dstBuf
    "type": unsigned short
  - "name": pitch
    "type": int
  - "name": pixelFormat
    "type": int
  - "name": handle
    "type": void
  - "name": jpegBuf
    "type": unsigned char
  - "name": jpegSize
    "type": unsigned long
  - "name": dstBuf
    "type": unsigned char
  - "name": pitch
    "type": int
  - "name": pixelFormat
    "type": int
  - "name": handle
    "type": void
  - "name": jpegBuf
    "type": unsigned char
  - "name": jpegSize
    "type": unsigned long
  - "name": dstBuf
    "type": short
  - "name": pitch
    "type": int
  - "name": pixelFormat
    "type": int
  - "name": handle
    "type": void
  - "name": jpegBuf
    "type": unsigned char
  - "name": jpegSize
    "type": unsigned long
  - "name": dstBuf
    "type": unsigned short
  - "name": pitch
    "type": int
  - "name": pixelFormat
    "type": int
  "return_type": int
  "signature": "/**\n * Decompress a lossless JPEG image with 13 to 16 bits of data\
    \ precision per\n * sample into a packed-pixel RGB, grayscale, or CMYK image with\
    \ the same\n * data precision.\n *\n * \\details \\copydetails tj3Decompress8()\n\
    \ */\nint tj3Decompress16(tjhandle handle, const unsigned char *jpegBuf,\n   \
    \                           size_t jpegSize, unsigned short *dstBuf,\n       \
    \                       int pitch, int pixelFormat);"
- "name": tj3LoadImage16
  "params":
  - "name": handle
    "type": void
  - "name": filename
    "type": char
  - "name": width
    "type": int
  - "name": align
    "type": int
  - "name": height
    "type": int
  - "name": pixelFormat
    "type": int
  - "name": handle
    "type": void
  - "name": filename
    "type": char
  - "name": width
    "type": int
  - "name": align
    "type": int
  - "name": height
    "type": int
  - "name": pixelFormat
    "type": int
  - "name": handle
    "type": void
  - "name": filename
    "type": char
  - "name": width
    "type": int
  - "name": align
    "type": int
  - "name": height
    "type": int
  - "name": pixelFormat
    "type": int
  - "name": handle
    "type": void
  - "name": filename
    "type": char
  - "name": width
    "type": int
  - "name": align
    "type": int
  - "name": height
    "type": int
  - "name": pixelFormat
    "type": int
  - "name": handle
    "type": void
  - "name": filename
    "type": char
  - "name": width
    "type": int
  - "name": align
    "type": int
  - "name": height
    "type": int
  - "name": pixelFormat
    "type": int
  - "name": handle
    "type": void
  - "name": filename
    "type": char
  - "name": width
    "type": int
  - "name": align
    "type": int
  - "name": height
    "type": int
  - "name": pixelFormat
    "type": int
  "return_type": unsigned short
  "signature": "/**\n * Load a packed-pixel image with 13 to 16 bits of data precision\
    \ per sample\n * from disk into memory.\n *\n * @param handle handle to a TurboJPEG\
    \ instance\n *\n * @param filename name of a file containing a packed-pixel image\
    \ in PBMPLUS\n * (PPM/PGM) format.  The target data precision (from 13 to 16 bits\
    \ per sample)\n * can be specified using #TJPARAM_PRECISION and defaults to 16\
    \ if\n * #TJPARAM_PRECISION is unset or out of range.  If the data precision of\
    \ the\n * PBMPLUS file does not match the target data precision, then upconverting\
    \ or\n * downconverting will be performed.\n *\n * @param width pointer to an\
    \ integer variable that will receive the width (in\n * pixels) of the packed-pixel\
    \ image\n *\n * @param align row alignment (in samples) of the packed-pixel buffer\
    \ to be\n * returned (must be a power of 2.)  Setting this parameter to n will\
    \ cause all\n * rows in the buffer to be padded to the nearest multiple of n samples\n\
    \ * (1 = unpadded.)\n *\n * @param height pointer to an integer variable that\
    \ will receive the height\n * (in pixels) of the packed-pixel image\n *\n * @param\
    \ pixelFormat pointer to an integer variable that specifies or will\n * receive\
    \ the pixel format of the packed-pixel buffer.  The behavior of this\n * function\
    \ will vary depending on the value of `*pixelFormat` passed to the\n * function:\n\
    \ * - @ref TJPF_UNKNOWN : The packed-pixel buffer returned by this function will\n\
    \ * use the most optimal pixel format for the file type, and `*pixelFormat` will\n\
    \ * contain the ID of that pixel format upon successful return from this\n * function.\n\
    \ * - @ref TJPF_GRAY : Only PGM files can be loaded.\n * - @ref TJPF_CMYK : The\
    \ RGB or grayscale pixels stored in the file will be\n * converted using a quick\
    \ & dirty algorithm that is suitable only for testing\n * purposes.  (Proper conversion\
    \ between CMYK and other formats requires a\n * color management system.)\n *\
    \ - Other @ref TJPF \"pixel formats\" : The packed-pixel buffer will use the\n\
    \ * specified pixel format, and pixel format conversion will be performed if\n\
    \ * necessary.\n *\n * @return a pointer to a newly-allocated buffer containing\
    \ the packed-pixel\n * image, converted to the chosen pixel format and with the\
    \ chosen row\n * alignment, or NULL if an error occurred (see #tj3GetErrorStr().)\
    \  This\n * buffer should be freed using #tj3Free().\n */\nunsigned short *tj3LoadImage16(tjhandle\
    \ handle, const char *filename,\n                                         int\
    \ *width, int align, int *height,\n                                         int\
    \ *pixelFormat);"
- "name": tj3SaveImage16
  "params":
  - "name": handle
    "type": void
  - "name": filename
    "type": char
  - "name": buffer
    "type": unsigned char
  - "name": width
    "type": int
  - "name": pitch
    "type": int
  - "name": height
    "type": int
  - "name": pixelFormat
    "type": int
  - "name": handle
    "type": void
  - "name": filename
    "type": char
  - "name": buffer
    "type": short
  - "name": width
    "type": int
  - "name": pitch
    "type": int
  - "name": height
    "type": int
  - "name": pixelFormat
    "type": int
  - "name": handle
    "type": void
  - "name": filename
    "type": char
  - "name": buffer
    "type": unsigned short
  - "name": width
    "type": int
  - "name": pitch
    "type": int
  - "name": height
    "type": int
  - "name": pixelFormat
    "type": int
  - "name": handle
    "type": void
  - "name": filename
    "type": char
  - "name": buffer
    "type": unsigned char
  - "name": width
    "type": int
  - "name": pitch
    "type": int
  - "name": height
    "type": int
  - "name": pixelFormat
    "type": int
  - "name": handle
    "type": void
  - "name": filename
    "type": char
  - "name": buffer
    "type": short
  - "name": width
    "type": int
  - "name": pitch
    "type": int
  - "name": height
    "type": int
  - "name": pixelFormat
    "type": int
  - "name": handle
    "type": void
  - "name": filename
    "type": char
  - "name": buffer
    "type": unsigned short
  - "name": width
    "type": int
  - "name": pitch
    "type": int
  - "name": height
    "type": int
  - "name": pixelFormat
    "type": int
  "return_type": int
  "signature": "/**\n * Save a packed-pixel image with 13 to 16 bits of data precision\
    \ per sample\n * from memory to disk.\n *\n * @param handle handle to a TurboJPEG\
    \ instance\n *\n * @param filename name of a file to which to save the packed-pixel\
    \ image,\n * which will be stored in PBMPLUS (PPM/PGM) format.  The source data\
    \ precision\n * (from 13 to 16 bits per sample) can be specified using #TJPARAM_PRECISION\n\
    \ * and defaults to 16 if #TJPARAM_PRECISION is unset or out of range.\n *\n *\
    \ @param buffer pointer to a buffer containing a packed-pixel RGB, grayscale,\n\
    \ * or CMYK image to be saved\n *\n * @param width width (in pixels) of the packed-pixel\
    \ image\n *\n * @param pitch samples per row in the packed-pixel image.  Setting\
    \ this\n * parameter to 0 is the equivalent of setting it to\n * <tt>width * #tjPixelSize[pixelFormat]</tt>.\n\
    \ *\n * @param height height (in pixels) of the packed-pixel image\n *\n * @param\
    \ pixelFormat pixel format of the packed-pixel image (see @ref TJPF\n * \"Pixel\
    \ formats\".)  If this parameter is set to @ref TJPF_GRAY, then the\n * image\
    \ will be stored in PGM format.  Otherwise, the image will be stored in\n * PPM\
    \ format.  If this parameter is set to @ref TJPF_CMYK, then the CMYK\n * pixels\
    \ will be converted to RGB using a quick & dirty algorithm that is\n * suitable\
    \ only for testing purposes.  (Proper conversion between CMYK and\n * other formats\
    \ requires a color management system.)\n *\n * @return 0 if successful, or -1\
    \ if an error occurred (see #tj3GetErrorStr().)\n */\nint tj3SaveImage16(tjhandle\
    \ handle, const char *filename,\n                             const unsigned short\
    \ *buffer, int width,\n                             int pitch, int height, int\
    \ pixelFormat);"
- "name": tj3Compress16
  "params":
  - "name": handle
    "type": void
  - "name": srcBuf
    "type": unsigned char
  - "name": width
    "type": int
  - "name": pitch
    "type": int
  - "name": height
    "type": int
  - "name": pixelFormat
    "type": int
  - "name": jpegBuf
    "type": unsigned char
  - "name": jpegSize
    "type": unsigned long
  - "name": handle
    "type": void
  - "name": srcBuf
    "type": short
  - "name": width
    "type": int
  - "name": pitch
    "type": int
  - "name": height
    "type": int
  - "name": pixelFormat
    "type": int
  - "name": jpegBuf
    "type": unsigned char
  - "name": jpegSize
    "type": unsigned long
  - "name": handle
    "type": void
  - "name": srcBuf
    "type": unsigned short
  - "name": width
    "type": int
  - "name": pitch
    "type": int
  - "name": height
    "type": int
  - "name": pixelFormat
    "type": int
  - "name": jpegBuf
    "type": unsigned char
  - "name": jpegSize
    "type": unsigned long
  - "name": handle
    "type": void
  - "name": srcBuf
    "type": unsigned char
  - "name": width
    "type": int
  - "name": pitch
    "type": int
  - "name": height
    "type": int
  - "name": pixelFormat
    "type": int
  - "name": jpegBuf
    "type": unsigned char
  - "name": jpegSize
    "type": unsigned long
  - "name": handle
    "type": void
  - "name": srcBuf
    "type": short
  - "name": width
    "type": int
  - "name": pitch
    "type": int
  - "name": height
    "type": int
  - "name": pixelFormat
    "type": int
  - "name": jpegBuf
    "type": unsigned char
  - "name": jpegSize
    "type": unsigned long
  - "name": handle
    "type": void
  - "name": srcBuf
    "type": unsigned short
  - "name": width
    "type": int
  - "name": pitch
    "type": int
  - "name": height
    "type": int
  - "name": pixelFormat
    "type": int
  - "name": jpegBuf
    "type": unsigned char
  - "name": jpegSize
    "type": unsigned long
  "return_type": int
  "signature": "/**\n * Compress a packed-pixel RGB, grayscale, or CMYK image with\
    \ 13 to 16 bits of\n * data precision per sample into a lossless JPEG image with\
    \ the same data\n * precision.\n *\n * @param handle handle to a TurboJPEG instance\
    \ that has been initialized for\n * compression\n *\n * @param srcBuf pointer\
    \ to a buffer containing a packed-pixel RGB, grayscale,\n * or CMYK source image\
    \ to be compressed.  This buffer should normally be\n * `pitch * height` samples\
    \ in size.  However, you can also use this parameter\n * to compress from a specific\
    \ region of a larger buffer.  The data precision\n * of the source image (from\
    \ 13 to 16 bits per sample) can be specified using\n * #TJPARAM_PRECISION and\
    \ defaults to 16 if #TJPARAM_PRECISION is unset or out\n * of range.\n *\n * @param\
    \ width width (in pixels) of the source image\n *\n * @param pitch samples per\
    \ row in the source image.  Normally this should be\n * <tt>width * #tjPixelSize[pixelFormat]</tt>,\
    \ if the image is unpadded.\n * (Setting this parameter to 0 is the equivalent\
    \ of setting it to\n * <tt>width * #tjPixelSize[pixelFormat]</tt>.)  However,\
    \ you can also use this\n * parameter to specify the row alignment/padding of\
    \ the source image, to skip\n * rows, or to compress from a specific region of\
    \ a larger buffer.\n *\n * @param height height (in pixels) of the source image\n\
    \ *\n * @param pixelFormat pixel format of the source image (see @ref TJPF\n *\
    \ \"Pixel formats\".)\n *\n * @param jpegBuf address of a pointer to a byte buffer\
    \ that will receive the\n * JPEG image.  TurboJPEG has the ability to reallocate\
    \ the JPEG buffer to\n * accommodate the size of the JPEG image.  Thus, you can\
    \ choose to:\n * -# pre-allocate the JPEG buffer with an arbitrary size using\
    \ #tj3Alloc() and\n * let TurboJPEG grow the buffer as needed,\n * -# set `*jpegBuf`\
    \ to NULL to tell TurboJPEG to allocate the buffer for you,\n * or\n * -# pre-allocate\
    \ the buffer to a \"worst case\" size determined by calling\n * #tj3JPEGBufSize()\
    \ and adding the return value to the size of the ICC profile\n * (if any) that\
    \ was previously associated with the TurboJPEG instance (see\n * #tj3SetICCProfile().)\
    \  This should ensure that the buffer never has to be\n * re-allocated.  (Setting\
    \ #TJPARAM_NOREALLOC guarantees that it won't be.)\n * .\n * If you choose option\
    \ 1 or 3, then `*jpegSize` should be set to the size of\n * your pre-allocated\
    \ buffer.  In any case, unless you have set\n * #TJPARAM_NOREALLOC, you should\
    \ always check `*jpegBuf` upon return from this\n * function, as it may have changed.\n\
    \ *\n * @param jpegSize pointer to a size_t variable that holds the size of the\
    \ JPEG\n * buffer.  If `*jpegBuf` points to a pre-allocated buffer, then `*jpegSize`\n\
    \ * should be set to the size of the buffer.  Upon return, `*jpegSize` will\n\
    \ * contain the size of the JPEG image (in bytes.)  If `*jpegBuf` points to a\n\
    \ * JPEG buffer that is being reused from a previous call to one of the JPEG\n\
    \ * compression functions, then `*jpegSize` is ignored.\n *\n * @return 0 if successful,\
    \ or -1 if an error occurred (see #tj3GetErrorStr()\n * and #tj3GetErrorCode().)\n\
    \ */\nint tj3Compress16(tjhandle handle, const unsigned short *srcBuf,\n     \
    \                       int width, int pitch, int height, int pixelFormat,\n \
    \                           unsigned char **jpegBuf, size_t *jpegSize);"
- "name": tjBufSizeYUV2
  "params":
  - "name": width
    "type": int
  - "name": align
    "type": int
  - "name": height
    "type": int
  - "name": subsamp
    "type": int
  "return_type": unsigned long
  "signature": "\nunsigned long tjBufSizeYUV2(int width, int align, int height,\n\
    \                                      int subsamp);"
- "name": tjBufSizeYUV
  "params":
  - "name": width
    "type": int
  - "name": height
    "type": int
  - "name": subsamp
    "type": int
  "return_type": unsigned long
  "signature": '

    unsigned long tjBufSizeYUV(int width, int height, int subsamp);'
- "name": TJBUFSIZEYUV
  "params":
  - "name": width
    "type": int
  - "name": height
    "type": int
  - "name": subsamp
    "type": int
  "return_type": unsigned long
  "signature": '

    unsigned long TJBUFSIZEYUV(int width, int height, int jpegSubsamp);'
- "name": tj3YUVPlaneSize
  "params":
  - "name": componentID
    "type": int
  - "name": width
    "type": int
  - "name": stride
    "type": int
  - "name": height
    "type": int
  - "name": subsamp
    "type": int
  "return_type": unsigned long
  "signature": "/**\n * The size of the buffer (in bytes) required to hold a YUV image\
    \ plane with\n * the given parameters.\n *\n * @param componentID ID number of\
    \ the image plane (0 = Y, 1 = U/Cb, 2 = V/Cr)\n *\n * @param width width (in pixels)\
    \ of the YUV image.  NOTE: This is the width of\n * the whole image, not the plane\
    \ width.\n *\n * @param stride bytes per row in the image plane.  Setting this\
    \ to 0 is the\n * equivalent of setting it to the plane width.\n *\n * @param\
    \ height height (in pixels) of the YUV image.  NOTE: This is the height\n * of\
    \ the whole image, not the plane height.\n *\n * @param subsamp level of chrominance\
    \ subsampling in the image (see\n * @ref TJSAMP \"Chrominance subsampling options\"\
    .)\n *\n * @return the size of the buffer (in bytes) required to hold the YUV\
    \ image\n * plane, or 0 if the arguments are out of bounds.\n */\nsize_t tj3YUVPlaneSize(int\
    \ componentID, int width, int stride,\n                                 int height,\
    \ int subsamp);"
- "name": tjPlaneSizeYUV
  "params":
  - "name": componentID
    "type": int
  - "name": width
    "type": int
  - "name": stride
    "type": int
  - "name": height
    "type": int
  - "name": subsamp
    "type": int
  "return_type": unsigned long
  "signature": "\nunsigned long tjPlaneSizeYUV(int componentID, int width, int stride,\n\
    \                                       int height, int subsamp);"
- "name": tj3YUVPlaneWidth
  "params":
  - "name": componentID
    "type": int
  - "name": width
    "type": int
  - "name": subsamp
    "type": int
  "return_type": int
  "signature": "/**\n * The plane width of a YUV image plane with the given parameters.\
    \  Refer to\n * @ref YUVnotes \"YUV Image Format Notes\" for a description of\
    \ plane width.\n *\n * @param componentID ID number of the image plane (0 = Y,\
    \ 1 = U/Cb, 2 = V/Cr)\n *\n * @param width width (in pixels) of the YUV image\n\
    \ *\n * @param subsamp level of chrominance subsampling in the image (see\n *\
    \ @ref TJSAMP \"Chrominance subsampling options\".)\n *\n * @return the plane\
    \ width of a YUV image plane with the given parameters, or 0\n * if the arguments\
    \ are out of bounds.\n */\nint tj3YUVPlaneWidth(int componentID, int width, int\
    \ subsamp);"
- "name": tjPlaneWidth
  "params":
  - "name": componentID
    "type": int
  - "name": width
    "type": int
  - "name": subsamp
    "type": int
  "return_type": int
  "signature": '

    int tjPlaneWidth(int componentID, int width, int subsamp);'
- "name": tj3YUVPlaneHeight
  "params":
  - "name": componentID
    "type": int
  - "name": height
    "type": int
  - "name": subsamp
    "type": int
  "return_type": int
  "signature": "/**\n * The plane height of a YUV image plane with the given parameters.\
    \  Refer to\n * @ref YUVnotes \"YUV Image Format Notes\" for a description of\
    \ plane height.\n *\n * @param componentID ID number of the image plane (0 = Y,\
    \ 1 = U/Cb, 2 = V/Cr)\n *\n * @param height height (in pixels) of the YUV image\n\
    \ *\n * @param subsamp level of chrominance subsampling in the image (see\n *\
    \ @ref TJSAMP \"Chrominance subsampling options\".)\n *\n * @return the plane\
    \ height of a YUV image plane with the given parameters, or\n * 0 if the arguments\
    \ are out of bounds.\n */\nint tj3YUVPlaneHeight(int componentID, int height,\
    \ int subsamp);"
- "name": tjPlaneHeight
  "params":
  - "name": componentID
    "type": int
  - "name": height
    "type": int
  - "name": subsamp
    "type": int
  "return_type": int
  "signature": '

    int tjPlaneHeight(int componentID, int height, int subsamp);'
- "name": tjInitCompress
  "params": []
  "return_type": void
  "signature": '

    tjhandle tjInitCompress(void);'
- "name": tj3SetICCProfile
  "params":
  - "name": handle
    "type": void
  - "name": iccBuf
    "type": unsigned char
  - "name": iccSize
    "type": unsigned long
  "return_type": int
  "signature": "/**\n * Embed an ICC (International Color Consortium) color management\
    \ profile in\n * JPEG images generated by subsequent compression and lossless\
    \ transformation\n * operations.\n *\n * @param handle handle to a TurboJPEG instance\
    \ that has been initialized for\n * compression\n *\n * @param iccBuf pointer\
    \ to a byte buffer containing an ICC profile.  A copy is\n * made of the ICC profile,\
    \ so this buffer can be freed or reused as soon as\n * this function returns.\
    \  Setting this parameter to NULL or setting `iccSize`\n * to 0 removes any ICC\
    \ profile that was previously associated with the\n * TurboJPEG instance.\n *\n\
    \ * @param iccSize size of the ICC profile (in bytes.)  Setting this parameter\n\
    \ * to 0 or setting `iccBuf` to NULL removes any ICC profile that was previously\n\
    \ * associated with the TurboJPEG instance.\n *\n * @return 0 if successful, or\
    \ -1 if an error occurred (see #tj3GetErrorStr().)\n */\nint tj3SetICCProfile(tjhandle\
    \ handle, unsigned char *iccBuf,\n                               size_t iccSize);"
- "name": tjCompress2
  "params":
  - "name": handle
    "type": void
  - "name": srcBuf
    "type": unsigned char
  - "name": width
    "type": int
  - "name": pitch
    "type": int
  - "name": height
    "type": int
  - "name": pixelFormat
    "type": int
  - "name": jpegBuf
    "type": unsigned char
  - "name": jpegSize
    "type": unsigned long
  - "name": jpegSubsamp
    "type": int
  - "name": jpegQual
    "type": int
  - "name": flags
    "type": int
  "return_type": int
  "signature": "\nint tjCompress2(tjhandle handle, const unsigned char *srcBuf,\n\
    \                          int width, int pitch, int height, int pixelFormat,\n\
    \                          unsigned char **jpegBuf, unsigned long *jpegSize,\n\
    \                          int jpegSubsamp, int jpegQual, int flags);"
- "name": tjCompress
  "params":
  - "name": handle
    "type": void
  - "name": srcBuf
    "type": unsigned char
  - "name": width
    "type": int
  - "name": pitch
    "type": int
  - "name": height
    "type": int
  - "name": pixelSize
    "type": int
  - "name": jpegBuf
    "type": unsigned char
  - "name": jpegSize
    "type": unsigned long
  - "name": jpegSubsamp
    "type": int
  - "name": jpegQual
    "type": int
  - "name": flags
    "type": int
  "return_type": int
  "signature": "\nint tjCompress(tjhandle handle, unsigned char *srcBuf, int width,\n\
    \                         int pitch, int height, int pixelSize,\n            \
    \             unsigned char *dstBuf, unsigned long *compressedSize,\n        \
    \                 int jpegSubsamp, int jpegQual, int flags);"
- "name": tj3CompressFromYUVPlanes8
  "params":
  - "name": handle
    "type": void
  - "name": srcPlanes
    "type": unsigned char
  - "name": width
    "type": int
  - "name": strides
    "type": int
  - "name": height
    "type": int
  - "name": jpegBuf
    "type": unsigned char
  - "name": jpegSize
    "type": unsigned long
  "return_type": int
  "signature": "/**\n * Compress a set of 8-bit-per-sample Y, U (Cb), and V (Cr) image\
    \ planes into\n * an 8-bit-per-sample JPEG image.\n *\n * @param handle handle\
    \ to a TurboJPEG instance that has been initialized for\n * compression\n *\n\
    \ * @param srcPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes\n\
    \ * (or just a Y plane, if compressing a grayscale image) that contain a YUV\n\
    \ * source image to be compressed.  These planes can be contiguous or\n * non-contiguous\
    \ in memory.  The size of each plane should match the value\n * returned by #tj3YUVPlaneSize()\
    \ for the given image width, height, strides,\n * and level of chrominance subsampling\
    \ (see #TJPARAM_SUBSAMP.)  Refer to\n * @ref YUVnotes \"YUV Image Format Notes\"\
    \ for more details.\n *\n * @param width width (in pixels) of the source image.\
    \  If the width is not an\n * even multiple of the iMCU width (see #tjMCUWidth),\
    \ then an intermediate\n * buffer copy will be performed.\n *\n * @param strides\
    \ an array of integers, each specifying the number of bytes per\n * row in the\
    \ corresponding plane of the YUV source image.  Setting the stride\n * for any\
    \ plane to 0 is the same as setting it to the plane width (see\n * @ref YUVnotes\
    \ \"YUV Image Format Notes\".)  If `strides` is NULL, then the\n * strides for\
    \ all planes will be set to their respective plane widths.  You\n * can adjust\
    \ the strides in order to specify an arbitrary amount of row\n * padding in each\
    \ plane or to create a JPEG image from a subregion of a larger\n * planar YUV\
    \ image.\n *\n * @param height height (in pixels) of the source image.  If the\
    \ height is not\n * an even multiple of the iMCU height (see #tjMCUHeight), then\
    \ an intermediate\n * buffer copy will be performed.\n *\n * @param jpegBuf address\
    \ of a pointer to a byte buffer that will receive the\n * JPEG image.  TurboJPEG\
    \ has the ability to reallocate the JPEG buffer to\n * accommodate the size of\
    \ the JPEG image.  Thus, you can choose to:\n * -# pre-allocate the JPEG buffer\
    \ with an arbitrary size using #tj3Alloc() and\n * let TurboJPEG grow the buffer\
    \ as needed,\n * -# set `*jpegBuf` to NULL to tell TurboJPEG to allocate the buffer\
    \ for you,\n * or\n * -# pre-allocate the buffer to a \"worst case\" size determined\
    \ by calling\n * #tj3JPEGBufSize() and adding the return value to the size of\
    \ the ICC profile\n * (if any) that was previously associated with the TurboJPEG\
    \ instance (see\n * #tj3SetICCProfile().)  This should ensure that the buffer\
    \ never has to be\n * re-allocated.  (Setting #TJPARAM_NOREALLOC guarantees that\
    \ it won't be.)\n * .\n * If you choose option 1 or 3, then `*jpegSize` should\
    \ be set to the size of\n * your pre-allocated buffer.  In any case, unless you\
    \ have set\n * #TJPARAM_NOREALLOC, you should always check `*jpegBuf` upon return\
    \ from this\n * function, as it may have changed.\n *\n * @param jpegSize pointer\
    \ to a size_t variable that holds the size of the JPEG\n * buffer.  If `*jpegBuf`\
    \ points to a pre-allocated buffer, then `*jpegSize`\n * should be set to the\
    \ size of the buffer.  Upon return, `*jpegSize` will\n * contain the size of the\
    \ JPEG image (in bytes.)  If `*jpegBuf` points to a\n * JPEG buffer that is being\
    \ reused from a previous call to one of the JPEG\n * compression functions, then\
    \ `*jpegSize` is ignored.\n *\n * @return 0 if successful, or -1 if an error occurred\
    \ (see #tj3GetErrorStr()\n * and #tj3GetErrorCode().)\n */\nint tj3CompressFromYUVPlanes8(tjhandle\
    \ handle,\n                                        const unsigned char * const\
    \ *srcPlanes,\n                                        int width, const int *strides,\n\
    \                                        int height, unsigned char **jpegBuf,\n\
    \                                        size_t *jpegSize);"
- "name": tjCompressFromYUVPlanes
  "params":
  - "name": handle
    "type": void
  - "name": srcPlanes
    "type": unsigned char
  - "name": width
    "type": int
  - "name": strides
    "type": int
  - "name": height
    "type": int
  - "name": subsamp
    "type": int
  - "name": jpegBuf
    "type": unsigned char
  - "name": jpegSize
    "type": unsigned long
  - "name": jpegQual
    "type": int
  - "name": flags
    "type": int
  "return_type": int
  "signature": "\nint tjCompressFromYUVPlanes(tjhandle handle,\n                 \
    \                     const unsigned char **srcPlanes,\n                     \
    \                 int width, const int *strides,\n                           \
    \           int height, int subsamp,\n                                      unsigned\
    \ char **jpegBuf,\n                                      unsigned long *jpegSize,\
    \ int jpegQual,\n                                      int flags);"
- "name": tj3CompressFromYUV8
  "params":
  - "name": handle
    "type": void
  - "name": srcBuf
    "type": unsigned char
  - "name": width
    "type": int
  - "name": align
    "type": int
  - "name": height
    "type": int
  - "name": jpegBuf
    "type": unsigned char
  - "name": jpegSize
    "type": unsigned long
  "return_type": int
  "signature": "/**\n * Compress an 8-bit-per-sample unified planar YUV image into\
    \ an\n * 8-bit-per-sample JPEG image.\n *\n * @param handle handle to a TurboJPEG\
    \ instance that has been initialized for\n * compression\n *\n * @param srcBuf\
    \ pointer to a buffer containing a unified planar YUV source\n * image to be compressed.\
    \  The size of this buffer should match the value\n * returned by #tj3YUVBufSize()\
    \ for the given image width, height, row\n * alignment, and level of chrominance\
    \ subsampling (see #TJPARAM_SUBSAMP.)  The\n * Y, U (Cb), and V (Cr) image planes\
    \ should be stored sequentially in the\n * buffer.  (Refer to @ref YUVnotes \"\
    YUV Image Format Notes\".)\n *\n * @param width width (in pixels) of the source\
    \ image.  If the width is not an\n * even multiple of the iMCU width (see #tjMCUWidth),\
    \ then an intermediate\n * buffer copy will be performed.\n *\n * @param align\
    \ row alignment (in bytes) of the source image (must be a power\n * of 2.)  Setting\
    \ this parameter to n indicates that each row in each plane of\n * the source\
    \ image is padded to the nearest multiple of n bytes\n * (1 = unpadded.)\n *\n\
    \ * @param height height (in pixels) of the source image.  If the height is not\n\
    \ * an even multiple of the iMCU height (see #tjMCUHeight), then an intermediate\n\
    \ * buffer copy will be performed.\n *\n * @param jpegBuf address of a pointer\
    \ to a byte buffer that will receive the\n * JPEG image.  TurboJPEG has the ability\
    \ to reallocate the JPEG buffer to\n * accommodate the size of the JPEG image.\
    \  Thus, you can choose to:\n * -# pre-allocate the JPEG buffer with an arbitrary\
    \ size using #tj3Alloc() and\n * let TurboJPEG grow the buffer as needed,\n *\
    \ -# set `*jpegBuf` to NULL to tell TurboJPEG to allocate the buffer for you,\n\
    \ * or\n * -# pre-allocate the buffer to a \"worst case\" size determined by calling\n\
    \ * #tj3JPEGBufSize() and adding the return value to the size of the ICC profile\n\
    \ * (if any) that was previously associated with the TurboJPEG instance (see\n\
    \ * #tj3SetICCProfile().)  This should ensure that the buffer never has to be\n\
    \ * re-allocated.  (Setting #TJPARAM_NOREALLOC guarantees that it won't be.)\n\
    \ * .\n * If you choose option 1 or 3, then `*jpegSize` should be set to the size\
    \ of\n * your pre-allocated buffer.  In any case, unless you have set\n * #TJPARAM_NOREALLOC,\
    \ you should always check `*jpegBuf` upon return from this\n * function, as it\
    \ may have changed.\n *\n * @param jpegSize pointer to a size_t variable that\
    \ holds the size of the JPEG\n * buffer.  If `*jpegBuf` points to a pre-allocated\
    \ buffer, then `*jpegSize`\n * should be set to the size of the buffer.  Upon\
    \ return, `*jpegSize` will\n * contain the size of the JPEG image (in bytes.)\
    \  If `*jpegBuf` points to a\n * JPEG buffer that is being reused from a previous\
    \ call to one of the JPEG\n * compression functions, then `*jpegSize` is ignored.\n\
    \ *\n * @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()\n\
    \ * and #tj3GetErrorCode().)\n */\nint tj3CompressFromYUV8(tjhandle handle,\n\
    \                                  const unsigned char *srcBuf, int width,\n \
    \                                 int align, int height,\n                   \
    \               unsigned char **jpegBuf, size_t *jpegSize);"
- "name": tjCompressFromYUV
  "params":
  - "name": handle
    "type": void
  - "name": srcBuf
    "type": unsigned char
  - "name": width
    "type": int
  - "name": align
    "type": int
  - "name": height
    "type": int
  - "name": subsamp
    "type": int
  - "name": jpegBuf
    "type": unsigned char
  - "name": jpegSize
    "type": unsigned long
  - "name": jpegQual
    "type": int
  - "name": flags
    "type": int
  "return_type": int
  "signature": "\nint tjCompressFromYUV(tjhandle handle, const unsigned char *srcBuf,\n\
    \                                int width, int align, int height, int subsamp,\n\
    \                                unsigned char **jpegBuf,\n                  \
    \              unsigned long *jpegSize, int jpegQual,\n                      \
    \          int flags);"
- "name": tj3EncodeYUVPlanes8
  "params":
  - "name": handle
    "type": void
  - "name": srcBuf
    "type": unsigned char
  - "name": width
    "type": int
  - "name": pitch
    "type": int
  - "name": height
    "type": int
  - "name": pixelFormat
    "type": int
  - "name": dstPlanes
    "type": unsigned char
  - "name": strides
    "type": int
  "return_type": int
  "signature": "/**\n * Encode an 8-bit-per-sample packed-pixel RGB or grayscale image\
    \ into separate\n * 8-bit-per-sample Y, U (Cb), and V (Cr) image planes.  This\
    \ function performs\n * color conversion (which is accelerated in the libjpeg-turbo\
    \ implementation)\n * but does not execute any of the other steps in the JPEG\
    \ compression process.\n *\n * @param handle handle to a TurboJPEG instance that\
    \ has been initialized for\n * compression\n *\n * @param srcBuf pointer to a\
    \ buffer containing a packed-pixel RGB or grayscale\n * source image to be encoded.\
    \  This buffer should normally be `pitch * height`\n * bytes in size.  However,\
    \ you can also use this parameter to encode from a\n * specific region of a larger\
    \ buffer.\n *\n *\n * @param width width (in pixels) of the source image\n *\n\
    \ * @param pitch bytes per row in the source image.  Normally this should be\n\
    \ * <tt>width * #tjPixelSize[pixelFormat]</tt>, if the image is unpadded.\n *\
    \ (Setting this parameter to 0 is the equivalent of setting it to\n * <tt>width\
    \ * #tjPixelSize[pixelFormat]</tt>.)  However, you can also use this\n * parameter\
    \ to specify the row alignment/padding of the source image, to skip\n * rows,\
    \ or to encode from a specific region of a larger packed-pixel image.\n *\n *\
    \ @param height height (in pixels) of the source image\n *\n * @param pixelFormat\
    \ pixel format of the source image (see @ref TJPF\n * \"Pixel formats\".)\n *\n\
    \ * @param dstPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes\n\
    \ * (or just a Y plane, if generating a grayscale image) that will receive the\n\
    \ * encoded image.  These planes can be contiguous or non-contiguous in memory.\n\
    \ * Use #tj3YUVPlaneSize() to determine the appropriate size for each plane\n\
    \ * based on the image width, height, strides, and level of chrominance\n * subsampling\
    \ (see #TJPARAM_SUBSAMP.)  Refer to @ref YUVnotes\n * \"YUV Image Format Notes\"\
    \ for more details.\n *\n * @param strides an array of integers, each specifying\
    \ the number of bytes per\n * row in the corresponding plane of the YUV image.\
    \  Setting the stride for any\n * plane to 0 is the same as setting it to the\
    \ plane width (see @ref YUVnotes\n * \"YUV Image Format Notes\".)  If `strides`\
    \ is NULL, then the strides for all\n * planes will be set to their respective\
    \ plane widths.  You can adjust the\n * strides in order to add an arbitrary amount\
    \ of row padding to each plane or\n * to encode an RGB or grayscale image into\
    \ a subregion of a larger planar YUV\n * image.\n *\n * @return 0 if successful,\
    \ or -1 if an error occurred (see #tj3GetErrorStr()\n * and #tj3GetErrorCode().)\n\
    \ */\nint tj3EncodeYUVPlanes8(tjhandle handle, const unsigned char *srcBuf,\n\
    \                                  int width, int pitch, int height,\n       \
    \                           int pixelFormat, unsigned char **dstPlanes,\n    \
    \                              int *strides);"
- "name": tjEncodeYUVPlanes
  "params":
  - "name": handle
    "type": void
  - "name": srcBuf
    "type": unsigned char
  - "name": width
    "type": int
  - "name": pitch
    "type": int
  - "name": height
    "type": int
  - "name": pixelFormat
    "type": int
  - "name": dstPlanes
    "type": unsigned char
  - "name": strides
    "type": int
  - "name": subsamp
    "type": int
  - "name": flags
    "type": int
  "return_type": int
  "signature": "\nint tjEncodeYUVPlanes(tjhandle handle, const unsigned char *srcBuf,\n\
    \                                int width, int pitch, int height,\n         \
    \                       int pixelFormat, unsigned char **dstPlanes,\n        \
    \                        int *strides, int subsamp, int flags);"
- "name": tj3EncodeYUV8
  "params":
  - "name": handle
    "type": void
  - "name": srcBuf
    "type": unsigned char
  - "name": width
    "type": int
  - "name": pitch
    "type": int
  - "name": height
    "type": int
  - "name": pixelFormat
    "type": int
  - "name": dstBuf
    "type": unsigned char
  - "name": align
    "type": int
  "return_type": int
  "signature": "/**\n * Encode an 8-bit-per-sample packed-pixel RGB or grayscale image\
    \ into an\n * 8-bit-per-sample unified planar YUV image.  This function performs\
    \ color\n * conversion (which is accelerated in the libjpeg-turbo implementation)\
    \ but\n * does not execute any of the other steps in the JPEG compression process.\n\
    \ *\n * @param handle handle to a TurboJPEG instance that has been initialized\
    \ for\n * compression\n *\n * @param srcBuf pointer to a buffer containing a packed-pixel\
    \ RGB or grayscale\n * source image to be encoded.  This buffer should normally\
    \ be `pitch * height`\n * bytes in size.  However, you can also use this parameter\
    \ to encode from a\n * specific region of a larger buffer.\n *\n * @param width\
    \ width (in pixels) of the source image\n *\n * @param pitch bytes per row in\
    \ the source image.  Normally this should be\n * <tt>width * #tjPixelSize[pixelFormat]</tt>,\
    \ if the image is unpadded.\n * (Setting this parameter to 0 is the equivalent\
    \ of setting it to\n * <tt>width * #tjPixelSize[pixelFormat]</tt>.)  However,\
    \ you can also use this\n * parameter to specify the row alignment/padding of\
    \ the source image, to skip\n * rows, or to encode from a specific region of a\
    \ larger packed-pixel image.\n *\n * @param height height (in pixels) of the source\
    \ image\n *\n * @param pixelFormat pixel format of the source image (see @ref\
    \ TJPF\n * \"Pixel formats\".)\n *\n * @param dstBuf pointer to a buffer that\
    \ will receive the unified planar YUV\n * image.  Use #tj3YUVBufSize() to determine\
    \ the appropriate size for this\n * buffer based on the image width, height, row\
    \ alignment, and level of\n * chrominance subsampling (see #TJPARAM_SUBSAMP.)\
    \  The Y, U (Cb), and V (Cr)\n * image planes will be stored sequentially in the\
    \ buffer.  (Refer to\n * @ref YUVnotes \"YUV Image Format Notes\".)\n *\n * @param\
    \ align row alignment (in bytes) of the YUV image (must be a power of\n * 2.)\
    \  Setting this parameter to n will cause each row in each plane of the\n * YUV\
    \ image to be padded to the nearest multiple of n bytes (1 = unpadded.)\n * To\
    \ generate images suitable for X Video, `align` should be set to 4.\n *\n * @return\
    \ 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()\n * and #tj3GetErrorCode().)\n\
    \ */\nint tj3EncodeYUV8(tjhandle handle, const unsigned char *srcBuf,\n      \
    \                      int width, int pitch, int height, int pixelFormat,\n  \
    \                          unsigned char *dstBuf, int align);"
- "name": tjEncodeYUV3
  "params":
  - "name": handle
    "type": void
  - "name": srcBuf
    "type": unsigned char
  - "name": width
    "type": int
  - "name": pitch
    "type": int
  - "name": height
    "type": int
  - "name": pixelFormat
    "type": int
  - "name": dstBuf
    "type": unsigned char
  - "name": align
    "type": int
  - "name": subsamp
    "type": int
  - "name": flags
    "type": int
  "return_type": int
  "signature": "\nint tjEncodeYUV3(tjhandle handle, const unsigned char *srcBuf,\n\
    \                           int width, int pitch, int height, int pixelFormat,\n\
    \                           unsigned char *dstBuf, int align, int subsamp,\n \
    \                          int flags);"
- "name": tjEncodeYUV2
  "params":
  - "name": handle
    "type": void
  - "name": srcBuf
    "type": unsigned char
  - "name": width
    "type": int
  - "name": pitch
    "type": int
  - "name": height
    "type": int
  - "name": pixelFormat
    "type": int
  - "name": dstBuf
    "type": unsigned char
  - "name": subsamp
    "type": int
  - "name": flags
    "type": int
  "return_type": int
  "signature": "\nint tjEncodeYUV2(tjhandle handle, unsigned char *srcBuf, int width,\n\
    \                           int pitch, int height, int pixelFormat,\n        \
    \                   unsigned char *dstBuf, int subsamp, int flags);"
- "name": tjEncodeYUV
  "params":
  - "name": handle
    "type": void
  - "name": srcBuf
    "type": unsigned char
  - "name": width
    "type": int
  - "name": pitch
    "type": int
  - "name": height
    "type": int
  - "name": pixelSize
    "type": int
  - "name": dstBuf
    "type": unsigned char
  - "name": subsamp
    "type": int
  - "name": flags
    "type": int
  "return_type": int
  "signature": "\nint tjEncodeYUV(tjhandle handle, unsigned char *srcBuf, int width,\n\
    \                          int pitch, int height, int pixelSize,\n           \
    \               unsigned char *dstBuf, int subsamp, int flags);"
- "name": tjInitDecompress
  "params": []
  "return_type": void
  "signature": '

    tjhandle tjInitDecompress(void);'
- "name": tj3DecompressHeader
  "params":
  - "name": handle
    "type": void
  - "name": jpegBuf
    "type": unsigned char
  - "name": jpegSize
    "type": unsigned long
  "return_type": int
  "signature": "/**\n * Retrieve information about a JPEG image without decompressing\
    \ it, or prime\n * the decompressor with quantization and Huffman tables.  If\
    \ a JPEG image is\n * passed to this function, then the @ref TJPARAM \"parameters\"\
    \ that describe\n * the JPEG image will be set when the function returns.  If\
    \ a JPEG image is\n * passed to this function and #TJPARAM_SAVEMARKERS is set\
    \ to `2` or `4`, then\n * the ICC profile (if any) will be extracted from the\
    \ JPEG image.\n * (#tj3GetICCProfile() can then be used to retrieve the profile.)\n\
    \ *\n * @param handle handle to a TurboJPEG instance that has been initialized\
    \ for\n * decompression\n *\n * @param jpegBuf pointer to a byte buffer containing\
    \ a JPEG image or an\n * \"abbreviated table specification\" (AKA \"tables-only\"\
    ) datastream.  Passing a\n * tables-only datastream to this function primes the\
    \ decompressor with\n * quantization and Huffman tables that can be used when\
    \ decompressing\n * subsequent \"abbreviated image\" datastreams.  This is useful,\
    \ for instance,\n * when decompressing video streams in which all frames share\
    \ the same\n * quantization and Huffman tables.\n *\n * @param jpegSize size of\
    \ the JPEG image or tables-only datastream (in bytes)\n *\n * @return 0 if successful,\
    \ or -1 if an error occurred (see #tj3GetErrorStr()\n * and #tj3GetErrorCode().)\n\
    \ */\nint tj3DecompressHeader(tjhandle handle,\n                             \
    \     const unsigned char *jpegBuf,\n                                  size_t\
    \ jpegSize);"
- "name": tjDecompressHeader3
  "params":
  - "name": handle
    "type": void
  - "name": jpegBuf
    "type": unsigned char
  - "name": jpegSize
    "type": unsigned long
  - "name": width
    "type": int
  - "name": height
    "type": int
  - "name": jpegSubsamp
    "type": int
  - "name": jpegColorspace
    "type": int
  "return_type": int
  "signature": "\nint tjDecompressHeader3(tjhandle handle,\n                     \
    \             const unsigned char *jpegBuf,\n                                \
    \  unsigned long jpegSize, int *width,\n                                  int\
    \ *height, int *jpegSubsamp,\n                                  int *jpegColorspace);"
- "name": tjDecompressHeader2
  "params":
  - "name": handle
    "type": void
  - "name": jpegBuf
    "type": unsigned char
  - "name": jpegSize
    "type": unsigned long
  - "name": width
    "type": int
  - "name": height
    "type": int
  - "name": jpegSubsamp
    "type": int
  "return_type": int
  "signature": "\nint tjDecompressHeader2(tjhandle handle, unsigned char *jpegBuf,\n\
    \                                  unsigned long jpegSize, int *width,\n     \
    \                             int *height, int *jpegSubsamp);"
- "name": tjDecompressHeader
  "params":
  - "name": handle
    "type": void
  - "name": jpegBuf
    "type": unsigned char
  - "name": jpegSize
    "type": unsigned long
  - "name": width
    "type": int
  - "name": height
    "type": int
  "return_type": int
  "signature": "\nint tjDecompressHeader(tjhandle handle, unsigned char *jpegBuf,\n\
    \                                 unsigned long jpegSize, int *width,\n      \
    \                           int *height);"
- "name": tj3GetICCProfile
  "params":
  - "name": handle
    "type": void
  - "name": iccBuf
    "type": unsigned char
  - "name": iccSize
    "type": unsigned long
  "return_type": int
  "signature": "/**\n * Retrieve the ICC (International Color Consortium) color management\
    \ profile\n * (if any) that was previously extracted from a JPEG image.\n *\n\
    \ * @note To extract the ICC profile from a JPEG image, call\n * #tj3DecompressHeader()\
    \ with #TJPARAM_SAVEMARKERS set to `2` or `4`.  Once\n * the ICC profile is retrieved,\
    \ it must be re-extracted before it can be\n * retrieved again.\n *\n * @param\
    \ handle handle to a TurboJPEG instance that has been initialized for\n * decompression\n\
    \ *\n * @param iccBuf address of a pointer to a byte buffer.  Upon return:\n *\
    \ - If `iccBuf` is not NULL and there is an ICC profile to retrieve, then\n *\
    \ `*iccBuf` will point to a byte buffer containing the ICC profile.  This\n *\
    \ buffer should be freed using #tj3Free().\n * - If `iccBuf` is not NULL and there\
    \ is no ICC profile to retrieve, then\n * `*iccBuf` will be NULL.\n * - If `iccBuf`\
    \ is NULL, then only the ICC profile size will be retrieved, and\n * the ICC profile\
    \ can be retrieved later.\n *\n * @param iccSize address of a size_t variable.\
    \  Upon return, the variable will\n * contain the ICC profile size (or 0 if there\
    \ is no ICC profile to retrieve.)\n *\n * @return 0 if successful, or -1 if an\
    \ error occurred (see #tj3GetErrorStr()\n * and #tj3GetErrorCode().)\n */\nint\
    \ tj3GetICCProfile(tjhandle handle, unsigned char **iccBuf,\n                \
    \               size_t *iccSize);"
- "name": tj3GetScalingFactors
  "params":
  - "name": numScalingFactors
    "type": int
  "return_type": tjscalingfactor
  "signature": "/**\n * Returns a list of fractional scaling factors that the JPEG\
    \ decompressor\n * supports.\n *\n * @param numScalingFactors pointer to an integer\
    \ variable that will receive\n * the number of elements in the list\n *\n * @return\
    \ a pointer to a list of fractional scaling factors, or NULL if an\n * error is\
    \ encountered (see #tj3GetErrorStr().)\n */\ntjscalingfactor *tj3GetScalingFactors(int\
    \ *numScalingFactors);"
- "name": tjGetScalingFactors
  "params":
  - "name": numScalingFactors
    "type": int
  "return_type": tjscalingfactor
  "signature": '

    tjscalingfactor *tjGetScalingFactors(int *numscalingfactors);'
- "name": tj3SetScalingFactor
  "params":
  - "name": handle
    "type": void
  - "name": scalingFactor
    "type": tjscalingfactor
  "return_type": int
  "signature": "/**\n * Set the scaling factor for subsequent lossy decompression\
    \ operations.\n *\n * @param handle handle to a TurboJPEG instance that has been\
    \ initialized for\n * decompression\n *\n * @param scalingFactor #tjscalingfactor\
    \ structure that specifies a fractional\n * scaling factor that the decompressor\
    \ supports (see #tj3GetScalingFactors()),\n * or <tt>#TJUNSCALED</tt> for no scaling.\
    \  Decompression scaling is a function\n * of the IDCT algorithm, so scaling factors\
    \ are generally limited to multiples\n * of 1/8.  If the entire JPEG image will\
    \ be decompressed, then the width and\n * height of the scaled destination image\
    \ can be determined by calling\n * #TJSCALED() with the JPEG width and height\
    \ (see #TJPARAM_JPEGWIDTH and\n * #TJPARAM_JPEGHEIGHT) and the specified scaling\
    \ factor.  When decompressing\n * into a planar YUV image, an intermediate buffer\
    \ copy will be performed if\n * the width or height of the scaled destination\
    \ image is not an even multiple\n * of the iMCU size (see #tjMCUWidth and #tjMCUHeight.)\
    \  Note that\n * decompression scaling is not available (and the specified scaling\
    \ factor is\n * ignored) when decompressing lossless JPEG images (see #TJPARAM_LOSSLESS),\n\
    \ * since the IDCT algorithm is not used with those images.  Note also that\n\
    \ * #TJPARAM_FASTDCT is ignored when decompression scaling is enabled.\n *\n *\
    \ @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr().)\n\
    \ */\nint tj3SetScalingFactor(tjhandle handle,\n                             \
    \     tjscalingfactor scalingFactor);"
- "name": tj3SetCroppingRegion
  "params":
  - "name": handle
    "type": void
  - "name": croppingRegion
    "type": tjregion
  "return_type": int
  "signature": "/**\n * Set the cropping region for partially decompressing a lossy\
    \ JPEG image into\n * a packed-pixel image\n *\n * @param handle handle to a TurboJPEG\
    \ instance that has been initialized for\n * decompression\n *\n * @param croppingRegion\
    \ #tjregion structure that specifies a subregion of the\n * JPEG image to decompress,\
    \ or <tt>#TJUNCROPPED</tt> for no cropping.  The\n * left boundary of the cropping\
    \ region must be evenly divisible by the scaled\n * iMCU width-- <tt>#TJSCALED(#tjMCUWidth[subsamp],\
    \ scalingFactor)</tt>, where\n * `subsamp` is the level of chrominance subsampling\
    \ in the JPEG image (see\n * #TJPARAM_SUBSAMP) and `scalingFactor` is the decompression\
    \ scaling factor\n * (see #tj3SetScalingFactor().)  The cropping region should\
    \ be specified\n * relative to the scaled image dimensions.  Unless `croppingRegion`\
    \ is\n * <tt>#TJUNCROPPED</tt>, the JPEG header must be read (see\n * #tj3DecompressHeader())\
    \ prior to calling this function.\n *\n * @return 0 if successful, or -1 if an\
    \ error occurred (see #tj3GetErrorStr().)\n */\nint tj3SetCroppingRegion(tjhandle\
    \ handle, tjregion croppingRegion);"
- "name": tjDecompress2
  "params":
  - "name": handle
    "type": void
  - "name": jpegBuf
    "type": unsigned char
  - "name": jpegSize
    "type": unsigned long
  - "name": dstBuf
    "type": unsigned char
  - "name": width
    "type": int
  - "name": pitch
    "type": int
  - "name": height
    "type": int
  - "name": pixelFormat
    "type": int
  - "name": flags
    "type": int
  "return_type": int
  "signature": "\nint tjDecompress2(tjhandle handle, const unsigned char *jpegBuf,\n\
    \                            unsigned long jpegSize, unsigned char *dstBuf,\n\
    \                            int width, int pitch, int height, int pixelFormat,\n\
    \                            int flags);"
- "name": tjDecompress
  "params":
  - "name": handle
    "type": void
  - "name": jpegBuf
    "type": unsigned char
  - "name": jpegSize
    "type": unsigned long
  - "name": dstBuf
    "type": unsigned char
  - "name": width
    "type": int
  - "name": pitch
    "type": int
  - "name": height
    "type": int
  - "name": pixelSize
    "type": int
  - "name": flags
    "type": int
  "return_type": int
  "signature": "\nint tjDecompress(tjhandle handle, unsigned char *jpegBuf,\n    \
    \                       unsigned long jpegSize, unsigned char *dstBuf,\n     \
    \                      int width, int pitch, int height, int pixelSize,\n    \
    \                       int flags);"
- "name": tj3DecompressToYUVPlanes8
  "params":
  - "name": handle
    "type": void
  - "name": jpegBuf
    "type": unsigned char
  - "name": jpegSize
    "type": unsigned long
  - "name": dstPlanes
    "type": unsigned char
  - "name": strides
    "type": int
  "return_type": int
  "signature": "/**\n * Decompress an 8-bit-per-sample JPEG image into separate 8-bit-per-sample\
    \ Y,\n * U (Cb), and V (Cr) image planes.  This function performs JPEG decompression\n\
    \ * but leaves out the color conversion step, so a planar YUV image is generated\n\
    \ * instead of a packed-pixel image.  The @ref TJPARAM \"parameters\" that\n *\
    \ describe the JPEG image will be set when this function returns.\n *\n * @param\
    \ handle handle to a TurboJPEG instance that has been initialized for\n * decompression\n\
    \ *\n * @param jpegBuf pointer to a byte buffer containing the JPEG image to\n\
    \ * decompress\n *\n * @param jpegSize size of the JPEG image (in bytes)\n *\n\
    \ * @param dstPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes\n\
    \ * (or just a Y plane, if decompressing a grayscale image) that will receive\n\
    \ * the decompressed image.  These planes can be contiguous or non-contiguous\
    \ in\n * memory.  Use #tj3YUVPlaneSize() to determine the appropriate size for\
    \ each\n * plane based on the scaled JPEG width and height (see #TJSCALED(),\n\
    \ * #TJPARAM_JPEGWIDTH, #TJPARAM_JPEGHEIGHT, and #tj3SetScalingFactor()),\n *\
    \ strides, and level of chrominance subsampling (see #TJPARAM_SUBSAMP.)  Refer\n\
    \ * to @ref YUVnotes \"YUV Image Format Notes\" for more details.\n *\n * @param\
    \ strides an array of integers, each specifying the number of bytes per\n * row\
    \ in the corresponding plane of the YUV image.  Setting the stride for any\n *\
    \ plane to 0 is the same as setting it to the scaled plane width (see\n * @ref\
    \ YUVnotes \"YUV Image Format Notes\".)  If `strides` is NULL, then the\n * strides\
    \ for all planes will be set to their respective scaled plane widths.\n * You\
    \ can adjust the strides in order to add an arbitrary amount of row\n * padding\
    \ to each plane or to decompress the JPEG image into a subregion of a\n * larger\
    \ planar YUV image.\n *\n * @return 0 if successful, or -1 if an error occurred\
    \ (see #tj3GetErrorStr()\n * and #tj3GetErrorCode().)\n */\nint tj3DecompressToYUVPlanes8(tjhandle\
    \ handle,\n                                        const unsigned char *jpegBuf,\n\
    \                                        size_t jpegSize,\n                  \
    \                      unsigned char **dstPlanes,\n                          \
    \              int *strides);"
- "name": tjDecompressToYUVPlanes
  "params":
  - "name": handle
    "type": void
  - "name": jpegBuf
    "type": unsigned char
  - "name": jpegSize
    "type": unsigned long
  - "name": dstPlanes
    "type": unsigned char
  - "name": width
    "type": int
  - "name": strides
    "type": int
  - "name": height
    "type": int
  - "name": flags
    "type": int
  "return_type": int
  "signature": "\nint tjDecompressToYUVPlanes(tjhandle handle,\n                 \
    \                     const unsigned char *jpegBuf,\n                        \
    \              unsigned long jpegSize,\n                                     \
    \ unsigned char **dstPlanes, int width,\n                                    \
    \  int *strides, int height, int flags);"
- "name": tj3DecompressToYUV8
  "params":
  - "name": handle
    "type": void
  - "name": jpegBuf
    "type": unsigned char
  - "name": jpegSize
    "type": unsigned long
  - "name": dstBuf
    "type": unsigned char
  - "name": align
    "type": int
  "return_type": int
  "signature": "/**\n * Decompress an 8-bit-per-sample JPEG image into an 8-bit-per-sample\
    \ unified\n * planar YUV image.  This function performs JPEG decompression but\
    \ leaves out\n * the color conversion step, so a planar YUV image is generated\
    \ instead of a\n * packed-pixel image.  The @ref TJPARAM \"parameters\" that describe\
    \ the JPEG\n * image will be set when this function returns.\n *\n * @param handle\
    \ handle to a TurboJPEG instance that has been initialized for\n * decompression\n\
    \ *\n * @param jpegBuf pointer to a byte buffer containing the JPEG image to\n\
    \ * decompress\n *\n * @param jpegSize size of the JPEG image (in bytes)\n *\n\
    \ * @param dstBuf pointer to a buffer that will receive the unified planar YUV\n\
    \ * decompressed image.  Use #tj3YUVBufSize() to determine the appropriate size\n\
    \ * for this buffer based on the scaled JPEG width and height (see #TJSCALED(),\n\
    \ * #TJPARAM_JPEGWIDTH, #TJPARAM_JPEGHEIGHT, and #tj3SetScalingFactor()), row\n\
    \ * alignment, and level of chrominance subsampling (see #TJPARAM_SUBSAMP.)  The\n\
    \ * Y, U (Cb), and V (Cr) image planes will be stored sequentially in the\n *\
    \ buffer.  (Refer to @ref YUVnotes \"YUV Image Format Notes\".)\n *\n * @param\
    \ align row alignment (in bytes) of the YUV image (must be a power of\n * 2.)\
    \  Setting this parameter to n will cause each row in each plane of the\n * YUV\
    \ image to be padded to the nearest multiple of n bytes (1 = unpadded.)\n * To\
    \ generate images suitable for X Video, `align` should be set to 4.\n *\n * @return\
    \ 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()\n * and #tj3GetErrorCode().)\n\
    \ */\nint tj3DecompressToYUV8(tjhandle handle,\n                             \
    \     const unsigned char *jpegBuf,\n                                  size_t\
    \ jpegSize,\n                                  unsigned char *dstBuf, int align);"
- "name": tjDecompressToYUV2
  "params":
  - "name": handle
    "type": void
  - "name": jpegBuf
    "type": unsigned char
  - "name": jpegSize
    "type": unsigned long
  - "name": dstBuf
    "type": unsigned char
  - "name": width
    "type": int
  - "name": align
    "type": int
  - "name": height
    "type": int
  - "name": flags
    "type": int
  "return_type": int
  "signature": "\nint tjDecompressToYUV2(tjhandle handle, const unsigned char *jpegBuf,\n\
    \                                 unsigned long jpegSize, unsigned char *dstBuf,\n\
    \                                 int width, int align, int height, int flags);"
- "name": tjDecompressToYUV
  "params":
  - "name": handle
    "type": void
  - "name": jpegBuf
    "type": unsigned char
  - "name": jpegSize
    "type": unsigned long
  - "name": dstBuf
    "type": unsigned char
  - "name": flags
    "type": int
  "return_type": int
  "signature": "\nint tjDecompressToYUV(tjhandle handle, unsigned char *jpegBuf,\n\
    \                                unsigned long jpegSize, unsigned char *dstBuf,\n\
    \                                int flags);"
- "name": tj3DecodeYUVPlanes8
  "params":
  - "name": handle
    "type": void
  - "name": srcPlanes
    "type": unsigned char
  - "name": strides
    "type": int
  - "name": dstBuf
    "type": unsigned char
  - "name": width
    "type": int
  - "name": pitch
    "type": int
  - "name": height
    "type": int
  - "name": pixelFormat
    "type": int
  "return_type": int
  "signature": "/**\n * Decode a set of 8-bit-per-sample Y, U (Cb), and V (Cr) image\
    \ planes into an\n * 8-bit-per-sample packed-pixel RGB or grayscale image.  This\
    \ function\n * performs color conversion (which is accelerated in the libjpeg-turbo\n\
    \ * implementation) but does not execute any of the other steps in the JPEG\n\
    \ * decompression process.\n *\n * @param handle handle to a TurboJPEG instance\
    \ that has been initialized for\n * decompression\n *\n * @param srcPlanes an\
    \ array of pointers to Y, U (Cb), and V (Cr) image planes\n * (or just a Y plane,\
    \ if decoding a grayscale image) that contain a YUV image\n * to be decoded. \
    \ These planes can be contiguous or non-contiguous in memory.\n * The size of\
    \ each plane should match the value returned by #tj3YUVPlaneSize()\n * for the\
    \ given image width, height, strides, and level of chrominance\n * subsampling\
    \ (see #TJPARAM_SUBSAMP.)  Refer to @ref YUVnotes\n * \"YUV Image Format Notes\"\
    \ for more details.\n *\n * @param strides an array of integers, each specifying\
    \ the number of bytes per\n * row in the corresponding plane of the YUV source\
    \ image.  Setting the stride\n * for any plane to 0 is the same as setting it\
    \ to the plane width (see\n * @ref YUVnotes \"YUV Image Format Notes\".)  If `strides`\
    \ is NULL, then the\n * strides for all planes will be set to their respective\
    \ plane widths.  You\n * can adjust the strides in order to specify an arbitrary\
    \ amount of row\n * padding in each plane or to decode a subregion of a larger\
    \ planar YUV image.\n *\n * @param dstBuf pointer to a buffer that will receive\
    \ the packed-pixel decoded\n * image.  This buffer should normally be `pitch *\
    \ height` bytes in size.\n * However, you can also use this parameter to decode\
    \ into a specific region of\n * a larger buffer.\n *\n * @param width width (in\
    \ pixels) of the source and destination images\n *\n * @param pitch bytes per\
    \ row in the destination image.  Normally this should\n * be set to <tt>width\
    \ * #tjPixelSize[pixelFormat]</tt>, if the destination\n * image should be unpadded.\
    \  (Setting this parameter to 0 is the equivalent of\n * setting it to <tt>width\
    \ * #tjPixelSize[pixelFormat]</tt>.)  However, you can\n * also use this parameter\
    \ to specify the row alignment/padding of the\n * destination image, to skip rows,\
    \ or to decode into a specific region of a\n * larger buffer.\n *\n * @param height\
    \ height (in pixels) of the source and destination images\n *\n * @param pixelFormat\
    \ pixel format of the destination image (see @ref TJPF\n * \"Pixel formats\".)\n\
    \ *\n * @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()\n\
    \ * and #tj3GetErrorCode().)\n */\nint tj3DecodeYUVPlanes8(tjhandle handle,\n\
    \                                  const unsigned char * const *srcPlanes,\n \
    \                                 const int *strides, unsigned char *dstBuf,\n\
    \                                  int width, int pitch, int height,\n       \
    \                           int pixelFormat);"
- "name": tjDecodeYUVPlanes
  "params":
  - "name": handle
    "type": void
  - "name": srcPlanes
    "type": unsigned char
  - "name": strides
    "type": int
  - "name": subsamp
    "type": int
  - "name": dstBuf
    "type": unsigned char
  - "name": width
    "type": int
  - "name": pitch
    "type": int
  - "name": height
    "type": int
  - "name": pixelFormat
    "type": int
  - "name": flags
    "type": int
  "return_type": int
  "signature": "\nint tjDecodeYUVPlanes(tjhandle handle,\n                       \
    \         const unsigned char **srcPlanes,\n                                const\
    \ int *strides, int subsamp,\n                                unsigned char *dstBuf,\
    \ int width, int pitch,\n                                int height, int pixelFormat,\
    \ int flags);"
- "name": tj3DecodeYUV8
  "params":
  - "name": handle
    "type": void
  - "name": srcBuf
    "type": unsigned char
  - "name": align
    "type": int
  - "name": dstBuf
    "type": unsigned char
  - "name": width
    "type": int
  - "name": pitch
    "type": int
  - "name": height
    "type": int
  - "name": pixelFormat
    "type": int
  "return_type": int
  "signature": "/**\n * Decode an 8-bit-per-sample unified planar YUV image into an\
    \ 8-bit-per-sample\n * packed-pixel RGB or grayscale image.  This function performs\
    \ color\n * conversion (which is accelerated in the libjpeg-turbo implementation)\
    \ but\n * does not execute any of the other steps in the JPEG decompression process.\n\
    \ *\n * @param handle handle to a TurboJPEG instance that has been initialized\
    \ for\n * decompression\n *\n * @param srcBuf pointer to a buffer containing a\
    \ unified planar YUV source\n * image to be decoded.  The size of this buffer\
    \ should match the value\n * returned by #tj3YUVBufSize() for the given image\
    \ width, height, row\n * alignment, and level of chrominance subsampling (see\
    \ #TJPARAM_SUBSAMP.)  The\n * Y, U (Cb), and V (Cr) image planes should be stored\
    \ sequentially in the\n * source buffer.  (Refer to @ref YUVnotes \"YUV Image\
    \ Format Notes\".)\n *\n * @param align row alignment (in bytes) of the YUV source\
    \ image (must be a\n * power of 2.)  Setting this parameter to n indicates that\
    \ each row in each\n * plane of the YUV source image is padded to the nearest\
    \ multiple of n bytes\n * (1 = unpadded.)\n *\n * @param dstBuf pointer to a buffer\
    \ that will receive the packed-pixel decoded\n * image.  This buffer should normally\
    \ be `pitch * height` bytes in size.\n * However, you can also use this parameter\
    \ to decode into a specific region of\n * a larger buffer.\n *\n * @param width\
    \ width (in pixels) of the source and destination images\n *\n * @param pitch\
    \ bytes per row in the destination image.  Normally this should\n * be set to\
    \ <tt>width * #tjPixelSize[pixelFormat]</tt>, if the destination\n * image should\
    \ be unpadded.  (Setting this parameter to 0 is the equivalent of\n * setting\
    \ it to <tt>width * #tjPixelSize[pixelFormat]</tt>.)  However, you can\n * also\
    \ use this parameter to specify the row alignment/padding of the\n * destination\
    \ image, to skip rows, or to decode into a specific region of a\n * larger buffer.\n\
    \ *\n * @param height height (in pixels) of the source and destination images\n\
    \ *\n * @param pixelFormat pixel format of the destination image (see @ref TJPF\n\
    \ * \"Pixel formats\".)\n *\n * @return 0 if successful, or -1 if an error occurred\
    \ (see #tj3GetErrorStr()\n * and #tj3GetErrorCode().)\n */\nint tj3DecodeYUV8(tjhandle\
    \ handle, const unsigned char *srcBuf,\n                            int align,\
    \ unsigned char *dstBuf, int width,\n                            int pitch, int\
    \ height, int pixelFormat);"
- "name": tjDecodeYUV
  "params":
  - "name": handle
    "type": void
  - "name": srcBuf
    "type": unsigned char
  - "name": align
    "type": int
  - "name": subsamp
    "type": int
  - "name": dstBuf
    "type": unsigned char
  - "name": width
    "type": int
  - "name": pitch
    "type": int
  - "name": height
    "type": int
  - "name": pixelFormat
    "type": int
  - "name": flags
    "type": int
  "return_type": int
  "signature": "\nint tjDecodeYUV(tjhandle handle, const unsigned char *srcBuf,\n\
    \                          int align, int subsamp, unsigned char *dstBuf,\n  \
    \                        int width, int pitch, int height, int pixelFormat,\n\
    \                          int flags);"
- "name": tjInitTransform
  "params": []
  "return_type": void
  "signature": '

    tjhandle tjInitTransform(void);'
- "name": tj3TransformBufSize
  "params":
  - "name": handle
    "type": void
  - "name": transform
    "type": struct tjtransform
  "return_type": unsigned long
  "signature": "/**\n * The maximum size of the buffer (in bytes) required to hold\
    \ a JPEG image\n * transformed with the given transform parameters and/or cropping\
    \ region.\n * This function is a wrapper for #tj3JPEGBufSize() that takes into\
    \ account\n * cropping, transposition of the width and height (which affects the\n\
    \ * destination image dimensions and level of chrominance subsampling),\n * grayscale\
    \ conversion, and the ICC profile (if any) that was previously\n * associated\
    \ with the TurboJPEG instance (see #tj3SetICCProfile()) or\n * extracted from\
    \ the source image (see #tj3GetICCProfile() and\n * #TJPARAM_SAVEMARKERS.)  The\
    \ JPEG header must be read (see\n * tj3DecompressHeader()) prior to calling this\
    \ function.\n *\n * @param handle handle to a TurboJPEG instance that has been\
    \ initialized for\n * lossless transformation\n *\n * @param transform pointer\
    \ to a #tjtransform structure that specifies the\n * transform parameters and/or\
    \ cropping region for the JPEG image.\n *\n * @return the maximum size of the\
    \ buffer (in bytes) required to hold the\n * transformed image, or 0 if an error\
    \ occurred (see #tj3GetErrorStr() and\n * #tj3GetErrorCode().)\n */\nsize_t tj3TransformBufSize(tjhandle\
    \ handle,\n                                     const tjtransform *transform);"
- "name": tj3Transform
  "params":
  - "name": handle
    "type": void
  - "name": jpegBuf
    "type": unsigned char
  - "name": jpegSize
    "type": unsigned long
  - "name": n
    "type": int
  - "name": dstBufs
    "type": unsigned char
  - "name": dstSizes
    "type": unsigned long
  - "name": t
    "type": struct tjtransform
  "return_type": int
  "signature": "/**\n * Losslessly transform a JPEG image into another JPEG image.\
    \  Lossless\n * transforms work by moving the raw DCT coefficients from one JPEG\
    \ image\n * structure to another without altering the values of the coefficients.\
    \  While\n * this is typically faster than decompressing the image, transforming\
    \ it, and\n * re-compressing it, lossless transforms are not free.  Each lossless\n\
    \ * transform requires reading and performing entropy decoding on all of the\n\
    \ * coefficients in the source image, regardless of the size of the destination\n\
    \ * image.  Thus, this function provides a means of generating multiple\n * transformed\
    \ images from the same source or applying multiple transformations\n * simultaneously,\
    \ in order to eliminate the need to read the source\n * coefficients multiple\
    \ times.\n *\n * @param handle handle to a TurboJPEG instance that has been initialized\
    \ for\n * lossless transformation\n *\n * @param jpegBuf pointer to a byte buffer\
    \ containing the JPEG source image to\n * transform\n *\n * @param jpegSize size\
    \ of the JPEG source image (in bytes)\n *\n * @param n the number of transformed\
    \ JPEG images to generate\n *\n * @param dstBufs pointer to an array of n byte\
    \ buffers.  `dstBufs[i]` will\n * receive a JPEG image that has been transformed\
    \ using the parameters in\n * `transforms[i]`.  TurboJPEG has the ability to reallocate\
    \ the JPEG\n * destination buffer to accommodate the size of the transformed JPEG\
    \ image.\n * Thus, you can choose to:\n * -# pre-allocate the JPEG destination\
    \ buffer with an arbitrary size using\n * #tj3Alloc() and let TurboJPEG grow the\
    \ buffer as needed,\n * -# set `dstBufs[i]` to NULL to tell TurboJPEG to allocate\
    \ the buffer for\n * you, or\n * -# pre-allocate the buffer to a \"worst case\"\
    \ size determined by calling\n * #tj3TransformBufSize().  Under normal circumstances,\
    \ this should ensure that\n * the buffer never has to be re-allocated.  (Setting\
    \ #TJPARAM_NOREALLOC\n * guarantees that it won't be.)  Note, however, that there\
    \ are some rare cases\n * (such as transforming images with a large amount of\
    \ embedded Exif data) in\n * which the transformed JPEG image will be larger than\
    \ the worst-case size,\n * and #TJPARAM_NOREALLOC cannot be used in those cases\
    \ unless the embedded\n * data is discarded using #TJXOPT_COPYNONE or #TJPARAM_SAVEMARKERS.\n\
    \ * .\n * If you choose option 1 or 3, then `dstSizes[i]` should be set to the\
    \ size of\n * your pre-allocated buffer.  In any case, unless you have set\n *\
    \ #TJPARAM_NOREALLOC, you should always check `dstBufs[i]` upon return from\n\
    \ * this function, as it may have changed.\n *\n * @param dstSizes pointer to\
    \ an array of n size_t variables that will receive\n * the actual sizes (in bytes)\
    \ of each transformed JPEG image.  If `dstBufs[i]`\n * points to a pre-allocated\
    \ buffer, then `dstSizes[i]` should be set to the\n * size of the buffer.  Upon\
    \ return, `dstSizes[i]` will contain the size of the\n * transformed JPEG image\
    \ (in bytes.)\n *\n * @param transforms pointer to an array of n #tjtransform\
    \ structures, each of\n * which specifies the transform parameters and/or cropping\
    \ region for the\n * corresponding transformed JPEG image.\n *\n * @return 0 if\
    \ successful, or -1 if an error occurred (see #tj3GetErrorStr()\n * and #tj3GetErrorCode().)\n\
    \ */\nint tj3Transform(tjhandle handle, const unsigned char *jpegBuf,\n      \
    \                     size_t jpegSize, int n, unsigned char **dstBufs,\n     \
    \                      size_t *dstSizes, const tjtransform *transforms);"
- "name": tjTransform
  "params":
  - "name": handle
    "type": void
  - "name": jpegBuf
    "type": unsigned char
  - "name": jpegSize
    "type": unsigned long
  - "name": n
    "type": int
  - "name": dstBufs
    "type": unsigned char
  - "name": dstSizes
    "type": unsigned long
  - "name": t
    "type": struct tjtransform
  - "name": flags
    "type": int
  "return_type": int
  "signature": "\nint tjTransform(tjhandle handle, const unsigned char *jpegBuf,\n\
    \                            unsigned long jpegSize, int n,\n                \
    \            unsigned char **dstBufs, unsigned long *dstSizes,\n             \
    \               tjtransform *transforms, int flags);"
- "name": tjLoadImage
  "params":
  - "name": filename
    "type": char
  - "name": width
    "type": int
  - "name": align
    "type": int
  - "name": height
    "type": int
  - "name": pixelFormat
    "type": int
  - "name": flags
    "type": int
  "return_type": unsigned char
  "signature": "\nunsigned char *tjLoadImage(const char *filename, int *width,\n \
    \                                    int align, int *height, int *pixelFormat,\n\
    \                                     int flags);"
- "name": tjSaveImage
  "params":
  - "name": filename
    "type": char
  - "name": buffer
    "type": unsigned char
  - "name": width
    "type": int
  - "name": pitch
    "type": int
  - "name": height
    "type": int
  - "name": pixelFormat
    "type": int
  - "name": flags
    "type": int
  "return_type": int
  "signature": "\nint tjSaveImage(const char *filename, unsigned char *buffer,\n \
    \                         int width, int pitch, int height, int pixelFormat,\n\
    \                          int flags);"
- "name": tj3Init
  "params":
  - "name": initType
    "type": int
  "return_type": void
  "signature": "/**\n * Create a new TurboJPEG instance.\n *\n * @param initType one\
    \ of the @ref TJINIT \"initialization options\"\n *\n * @return a handle to the\
    \ newly-created instance, or NULL if an error occurred\n * (see #tj3GetErrorStr().)\n\
    \ */\ntjhandle tj3Init(int initType);"
- "name": tj3Destroy
  "params":
  - "name": handle
    "type": void
  "return_type": void
  "signature": "/**\n * Destroy a TurboJPEG instance.\n *\n * @param handle handle\
    \ to a TurboJPEG instance.  If the handle is NULL, then\n * this function has\
    \ no effect.\n */\nvoid tj3Destroy(tjhandle handle);"
- "name": tjDestroy
  "params":
  - "name": handle
    "type": void
  "return_type": int
  "signature": '

    int tjDestroy(tjhandle handle);'
- "name": tj3GetErrorStr
  "params":
  - "name": handle
    "type": void
  "return_type": char
  "signature": "/**\n * Returns a descriptive error message explaining why the last\
    \ command failed.\n *\n * @param handle handle to a TurboJPEG instance, or NULL\
    \ if the error was\n * generated by a global function (but note that retrieving\
    \ the error message\n * for a global function is thread-safe only on platforms\
    \ that support\n * thread-local storage.)\n *\n * @return a descriptive error\
    \ message explaining why the last command failed.\n */\nchar *tj3GetErrorStr(tjhandle\
    \ handle);"
- "name": tjGetErrorStr2
  "params":
  - "name": handle
    "type": void
  "return_type": char
  "signature": '

    char *tjGetErrorStr2(tjhandle handle);'
- "name": tjGetErrorStr
  "params": []
  "return_type": char
  "signature": '

    char *tjGetErrorStr(void);'
- "name": tj3GetErrorCode
  "params":
  - "name": handle
    "type": void
  "return_type": int
  "signature": "/**\n * Returns a code indicating the severity of the last error.\
    \  See\n * @ref TJERR \"Error codes\".\n *\n * @param handle handle to a TurboJPEG\
    \ instance\n *\n * @return a code indicating the severity of the last error. \
    \ See\n * @ref TJERR \"Error codes\".\n */\nint tj3GetErrorCode(tjhandle handle);"
- "name": tjGetErrorCode
  "params":
  - "name": handle
    "type": void
  "return_type": int
  "signature": '

    int tjGetErrorCode(tjhandle handle);'
- "name": tj3Set
  "params":
  - "name": handle
    "type": void
  - "name": param
    "type": int
  - "name": value
    "type": int
  "return_type": int
  "signature": "/**\n * Set the value of a parameter.\n *\n * @param handle handle\
    \ to a TurboJPEG instance\n *\n * @param param one of the @ref TJPARAM \"parameters\"\
    \n *\n * @param value value of the parameter (refer to @ref TJPARAM\n * \"parameter\
    \ documentation\")\n *\n * @return 0 if successful, or -1 if an error occurred\
    \ (see #tj3GetErrorStr().)\n */\nint tj3Set(tjhandle handle, int param, int value);"
- "name": tj3Get
  "params":
  - "name": handle
    "type": void
  - "name": param
    "type": int
  "return_type": int
  "signature": "/**\n * Get the value of a parameter.\n *\n * @param handle handle\
    \ to a TurboJPEG instance\n *\n * @param param one of the @ref TJPARAM \"parameters\"\
    \n *\n * @return the value of the specified parameter, or -1 if the value is unknown.\n\
    \ */\nint tj3Get(tjhandle handle, int param);"
- "name": tj3Alloc
  "params":
  - "name": bytes
    "type": unsigned long
  "return_type": void
  "signature": "/**\n * Allocate a byte buffer for use with TurboJPEG.  You should\
    \ always use this\n * function to allocate the JPEG destination buffer(s) for\
    \ the compression and\n * transform functions unless you are disabling automatic\
    \ buffer (re)allocation\n * (by setting #TJPARAM_NOREALLOC.)\n *\n * @param bytes\
    \ the number of bytes to allocate\n *\n * @return a pointer to a newly-allocated\
    \ buffer with the specified number of\n * bytes.\n *\n * @see tj3Free()\n */\n\
    void *tj3Alloc(size_t bytes);"
- "name": tjAlloc
  "params":
  - "name": bytes
    "type": int
  "return_type": unsigned char
  "signature": '

    unsigned char *tjAlloc(int bytes);'
- "name": tj3Free
  "params":
  - "name": buf
    "type": void
  "return_type": void
  "signature": "/**\n * Free a byte buffer previously allocated by TurboJPEG.  You\
    \ should always use\n * this function to free JPEG destination buffer(s) that\
    \ were automatically\n * (re)allocated by the compression and transform functions\
    \ or that were\n * manually allocated using #tj3Alloc().\n *\n * @param buffer\
    \ address of the buffer to free.  If the address is NULL, then\n * this function\
    \ has no effect.\n *\n * @see tj3Alloc()\n */\nvoid tj3Free(void *buffer);"
- "name": tjFree
  "params":
  - "name": buf
    "type": unsigned char
  "return_type": void
  "signature": '

    void tjFree(unsigned char *buffer);'
- "name": tj3JPEGBufSize
  "params":
  - "name": width
    "type": int
  - "name": height
    "type": int
  - "name": jpegSubsamp
    "type": int
  "return_type": unsigned long
  "signature": "/**\n * The maximum size of the buffer (in bytes) required to hold\
    \ a JPEG image with\n * the given parameters.  The number of bytes returned by\
    \ this function is\n * larger than the size of the uncompressed source image.\
    \  The reason for this\n * is that the JPEG format uses 16-bit coefficients, so\
    \ it is possible for a\n * very high-quality source image with very high-frequency\
    \ content to expand\n * rather than compress when converted to the JPEG format.\
    \  Such images\n * represent very rare corner cases, but since there is no way\
    \ to predict the\n * size of a JPEG image prior to compression, the corner cases\
    \ have to be\n * handled.\n *\n * @param width width (in pixels) of the image\n\
    \ *\n * @param height height (in pixels) of the image\n *\n * @param jpegSubsamp\
    \ the level of chrominance subsampling to be used when\n * generating the JPEG\
    \ image (see @ref TJSAMP\n * \"Chrominance subsampling options\".)  #TJSAMP_UNKNOWN\
    \ is treated like\n * #TJSAMP_444, since a buffer large enough to hold a JPEG\
    \ image with no\n * subsampling should also be large enough to hold a JPEG image\
    \ with an\n * arbitrary level of subsampling.  Note that lossless JPEG images\
    \ always\n * use #TJSAMP_444.\n *\n * @return the maximum size of the buffer (in\
    \ bytes) required to hold the\n * image, or 0 if the arguments are out of bounds.\n\
    \ */\nsize_t tj3JPEGBufSize(int width, int height, int jpegSubsamp);"
- "name": tjBufSize
  "params":
  - "name": width
    "type": int
  - "name": height
    "type": int
  - "name": jpegSubsamp
    "type": int
  "return_type": unsigned long
  "signature": '

    unsigned long tjBufSize(int width, int height, int jpegSubsamp);'
- "name": TJBUFSIZE
  "params":
  - "name": width
    "type": int
  - "name": height
    "type": int
  "return_type": unsigned long
  "signature": '

    unsigned long TJBUFSIZE(int width, int height);'
- "name": tj3YUVBufSize
  "params":
  - "name": width
    "type": int
  - "name": align
    "type": int
  - "name": height
    "type": int
  - "name": subsamp
    "type": int
  "return_type": unsigned long
  "signature": "/**\n * The size of the buffer (in bytes) required to hold a unified\
    \ planar YUV\n * image with the given parameters.\n *\n * @param width width (in\
    \ pixels) of the image\n *\n * @param align row alignment (in bytes) of the image\
    \ (must be a power of 2.)\n * Setting this parameter to n specifies that each\
    \ row in each plane of the\n * image will be padded to the nearest multiple of\
    \ n bytes (1 = unpadded.)\n *\n * @param height height (in pixels) of the image\n\
    \ *\n * @param subsamp level of chrominance subsampling in the image (see\n *\
    \ @ref TJSAMP \"Chrominance subsampling options\".)\n *\n * @return the size of\
    \ the buffer (in bytes) required to hold the image, or 0\n * if the arguments\
    \ are out of bounds.\n */\nsize_t tj3YUVBufSize(int width, int align, int height,\
    \ int subsamp);"
"language": "c"
"project": "libjpeg-turbo"
"target_name": "cjpeg_fuzzer_2_1_x"
"target_path": "/src/libjpeg-turbo.2.1.x/fuzz/cjpeg.cc"
